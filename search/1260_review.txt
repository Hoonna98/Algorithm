문제
그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 
단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 
더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.

입력
첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 
탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 
어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.

출력
첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. 
V부터 방문된 점을 순서대로 출력하면 된다.


dfs 
깊이를 우선적으로 탐색하기 위해서 접해있는 간선을 찾기 위해 dfs를 recursive하게 바로 실행시켜준다.

bfs recursive 방법
그래프의 이어짐을 표시하기 위해 입력을 이중배열로 graph라는 변수에 넣어주고 
정점에 번호가 작은 것을 먼저 방문하기 위해 sorted 함수를 람다함수를 이용해 두번째 자표로 정렬해주었다.
이 과정에서 M * log(M)의 시간 복잡도 소요
bfs는 넓이 우선 탐색 과정으로 주변 노드를 전부 탐색하여 주변에 있다면 queue에 더해주고 방문표시를 바로 해주어 넓이를 우선순위로 두고,
근처 노드를 다 추가하게 되면 popleft를 사용하여 다음 노드도 똑같은 방식으로 진행되게 하였다. 
queue에 더해줄 때 방문 표시를 하지 않게 되면 이후에 추가 되는 노드 또한 방문 표시를 하게된다.
시간 복잡도 : ((N-1) * M * 2) + (M * log(M))

bfs loop 방법
graph에 recursive방법 처럼 추가하게 되면 loop과정이 복잡하게 되어 matrix에 해당 정점들에 1을 표시하였다.
이 과정에서 recursive보다 공간적인 낭비를 하게된다. (사용하지 않는 부분 또한 공간을 차지하기 때문에)
-> 공간적 측면에서 n+1 배 낭비
recursive와 비슷하게 동작하지만 함수를 호출하는 overhead가 없다.
시간 복잡도 : (N-1)(queue에 최대로 들어갈 수 있는 정점의 수) * (N+1)

시간 복잡도는 N이 M보다 비교적 클 때 recursive 방법이 효율적이고, 그렇지 않을 때는 loop방법이 효율적이다.

파이토닉한 코드
loop function : graph = [[0] * (n+1) for _ in range(n+1)]
recursive function : graph = sorted(graph, key = lambda x:x[1])